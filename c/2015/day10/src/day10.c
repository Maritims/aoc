#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "aoc.h"

// Find the nth term in the look and say sequence.
// The nth term is generated by reading the (n-1)th term.
char* look_and_say(char* input) {
    size_t length = strlen(input);
    // Estimate maximum output length.
    size_t max_output_length = length * 2;
    // Allocate output pointer.
    char* output = calloc(max_output_length, sizeof(char));
    if (output == NULL) {
        fprintf(stderr, "Unable to allocate memory for output\n");
        return NULL;
    }

    size_t i = 0;
    // Keep track of the end of the output for use in snprintf() calls.
    // By keeping track of the end of the output we save plenty of calls to strlen and thus increase the performance of the application severely.
    size_t output_end_ptr = 0;

    while (i < length) {
        // We're currently looking at the first occurrence of a digit in the input string.
        size_t occurrences = 1;
        // Look ahead at the next digit to see if it's the same.
        while (i < length - 1 && input[i] == input[i + 1]) {
            // Move to the next digit.
            i += 1;
            occurrences += 1;
        }
        output_end_ptr += snprintf(output + output_end_ptr, max_output_length - output_end_ptr, "%zu%c", occurrences, input[i]);
        i += 1;
    }

    return output;
}

void test_look_and_say(char* input, char* expected_result) {
    char* output = look_and_say(input);
    bool success = strcmp(output, expected_result) == 0;
    printf("%s(%s): %s - expected: %s, received: %s\n", __func__, input, success ? "OK" : "Not OK", expected_result, output);
}

int main(int argc, char* argv[]) {
    test_look_and_say("1", "11");
    test_look_and_say("11", "21");
    test_look_and_say("21", "1211");
    test_look_and_say("1211", "111221");

    Solution *solution = solution_create(2015, 10);

    char* file_content = get_file(argv[1]);
    for(int i = 0; i < 50; i++)
    {
        if(i == 40) {
            sprintf(solution->part_one.result, "%zu", strlen(file_content));
            solution_part_finalize(&solution->part_one);
        }

        char *next_sequence = look_and_say(file_content);
        // Free the memory held by file_content and point file_content to new memory allocated for next_sequence.
        free(file_content);
        file_content = next_sequence;
    }
    sprintf(solution->part_two.result, "%zu", strlen(file_content));
    solution_part_finalize(&solution->part_two);
    solution_finalize(solution);
    solution_print(solution);

    return 0;
}